<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Honeycomb Pattern Designer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: #f3f4f6;
            overflow: hidden;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #c1c1c1; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #a8a8a8; }

        .canvas-container {
            background-image: 
                linear-gradient(45deg, #e5e7eb 25%, transparent 25%), 
                linear-gradient(-45deg, #e5e7eb 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #e5e7eb 75%), 
                linear-gradient(-45deg, transparent 75%, #e5e7eb 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            cursor: default;
        }
        
        .cursor-grab { cursor: grab; }
        .cursor-grabbing { cursor: grabbing; }

        /* Dimension Markers */
        .dimension-line { position: absolute; background-color: #0ea5e9; }
        .dimension-arrow {
            position: absolute; width: 0; height: 0; 
            border-left: 5px solid transparent; border-right: 5px solid transparent;
            border-bottom: 8px solid #0ea5e9;
        }
        .dimension-text {
            color: #0ea5e9; font-weight: 500; font-size: 1.2rem;
            text-shadow: 0 1px 2px rgba(255,255,255,0.8); white-space: nowrap;
        }

        /* Color Picker */
        .cp-saturation {
            width: 100%; height: 150px; position: relative;
            background: linear-gradient(to bottom, transparent, #000), linear-gradient(to right, #fff, transparent);
            cursor: crosshair; border-radius: 6px 6px 0 0;
        }
        .cp-hue {
            width: 100%; height: 16px; margin-top: 10px;
            background: linear-gradient(to right, #f00, #ff0, #0f0, #0ff, #00f, #f0f, #f00);
            cursor: pointer; border-radius: 8px; position: relative;
        }
        .cp-thumb {
            width: 12px; height: 12px; border: 2px solid white; border-radius: 50%;
            box-shadow: 0 0 2px rgba(0,0,0,0.5); position: absolute;
            transform: translate(-50%, -50%); pointer-events: none;
        }
        .cp-hue-thumb {
            width: 10px; height: 20px; background: white;
            box-shadow: 0 0 2px rgba(0,0,0,0.5); position: absolute; top: 50%;
            transform: translate(-50%, -50%); pointer-events: none; border-radius: 2px;
        }
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }

        /* Printing Styles */
        @media print {
            @page { size: auto; margin: 0mm; }
            body { background: white; height: auto; overflow: visible; display: block; }
            aside, .toolbar-area, .canvas-container-bg { display: none !important; }
            
            #print-area {
                display: block !important;
                position: absolute;
                top: 0; left: 0;
                width: 100%;
                height: 100%;
                padding: 20px;
            }
            
            /* Hide interactive markers in print */
            .dimension-line, .dimension-arrow, .dimension-text, #row-numbers, #canvas-ui-border { display: none !important; }
            
            /* Ensure SVG prints */
            #grid-svg { display: block !important; overflow: visible !important; }
            #canvas-wrapper { box-shadow: none !important; border: none !important; margin: 0 !important; transform: none !important; }
        }
        
        #print-area { display: none; }

        /* SVG specific */
        #grid-svg circle {
            transition: fill 0.1s;
        }
        #grid-svg circle:hover {
            filter: brightness(0.95);
        }

        /* Drawing preview overlay */
        #preview-layer {
            pointer-events: none;
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
        }
        /* Save/Load modal */
        .modal-overlay {
            position: fixed; inset: 0; background: rgba(0,0,0,0.4);
            display: flex; align-items: center; justify-content: center;
            z-index: 1000; opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s;
        }
        .modal-overlay.open { opacity: 1; visibility: visible; }
        .modal-panel {
            background: white; border-radius: 12px; box-shadow: 0 25px 50px -12px rgba(0,0,0,0.25);
            min-width: 320px; max-width: 90vw; max-height: 85vh; overflow: hidden; display: flex; flex-direction: column;
        }
        .modal-panel h2 { margin: 0; font-size: 1.1rem; font-weight: 600; color: #1e293b; }
        .save-load-list { max-height: 280px; overflow-y: auto; }

        .tool-btn.active {
            background: #3b82f6;
            color: white;
            border-color: #2563eb;
        }
        .tool-btn {
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
            background: #f8fafc;
            color: #475569;
            cursor: pointer;
            transition: all 0.15s;
        }
        .tool-btn:hover {
            background: #e2e8f0;
            color: #1e293b;
        }
    </style>
</head>
<body class="h-screen flex flex-col md:flex-row text-slate-700">

    <!-- Sidebar -->
    <aside class="w-full md:w-80 bg-white shadow-xl z-20 flex flex-col h-full border-r border-slate-200 print:hidden">
        <div class="p-5 border-b border-slate-100">
            <h1 class="text-xl font-bold text-slate-800 flex items-center gap-2">
                <i class="fa-solid fa-cubes-stacked text-blue-500"></i> Pattern Pro
            </h1>
        </div>

        <div class="flex-1 overflow-y-auto p-5 space-y-6">
            
            <!-- Color Picker -->
            <div class="bg-white rounded-lg border border-slate-200 shadow-sm p-1">
                <div id="cp-saturation" class="cp-saturation" style="background-color: red;">
                    <div id="cp-sat-thumb" class="cp-thumb" style="top: 0%; left: 100%;"></div>
                </div>
                <div class="p-3">
                    <div id="cp-hue" class="cp-hue">
                        <div id="cp-hue-thumb" class="cp-hue-thumb" style="left: 0%;"></div>
                    </div>
                    <div class="flex items-center gap-3 mt-4">
                        <div class="w-10 h-10 rounded-full shadow-inner border border-slate-200 flex-shrink-0" id="color-preview" style="background-color: #ff0000;"></div>
                        <div class="flex-1 relative">
                            <span class="absolute left-3 top-1/2 -translate-y-1/2 text-slate-400 text-xs">#</span>
                            <input type="text" id="hex-input" value="FF0000" class="w-full pl-6 pr-2 py-1.5 text-sm border border-slate-300 rounded focus:outline-none focus:border-blue-500 uppercase font-mono">
                        </div>
                        <button id="add-to-palette" class="p-2 text-slate-500 hover:text-blue-600 hover:bg-blue-50 rounded transition" title="Save to Palette">
                            <i class="fa-solid fa-plus"></i>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Palette -->
            <div>
                <div class="flex justify-between items-center mb-2">
                    <label class="text-xs font-bold uppercase tracking-wider text-slate-500">Palette</label>
                    <button id="clear-palette" class="text-xs text-red-400 hover:text-red-600">Clear</button>
                </div>
                <div class="grid grid-cols-6 gap-2" id="palette-container">
                    <!-- Generated by JS -->
                </div>
            </div>

            <hr class="border-slate-100">

            <!-- Dimensions -->
            <div class="space-y-4">
                <div class="flex justify-between items-end">
                    <label class="text-sm font-semibold text-slate-700">Canvas Size</label>
                    <div class="flex bg-slate-100 rounded p-0.5">
                        <button class="unit-btn px-2 py-0.5 text-xs font-medium rounded bg-white shadow-sm text-slate-800" data-unit="in">IN</button>
                        <button class="unit-btn px-2 py-0.5 text-xs font-medium rounded text-slate-500 hover:text-slate-800" data-unit="cm">CM</button>
                        <button class="unit-btn px-2 py-0.5 text-xs font-medium rounded text-slate-500 hover:text-slate-800" data-unit="mm">MM</button>
                    </div>
                </div>

                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label class="block text-xs text-slate-500 mb-1">Width</label>
                        <input type="number" id="input-width" value="1.37" step="0.01" class="w-full p-2 border border-slate-300 rounded focus:ring-2 focus:ring-blue-500 focus:outline-none text-slate-700 font-mono">
                    </div>
                    <div>
                        <label class="block text-xs text-slate-500 mb-1">Height</label>
                        <input type="number" id="input-height" value="3.69" step="0.01" class="w-full p-2 border border-slate-300 rounded focus:ring-2 focus:ring-blue-500 focus:outline-none text-slate-700 font-mono">
                    </div>
                </div>

                <!-- Dot Size -->
                <div>
                    <label class="block text-xs text-slate-500 mb-1 flex justify-between">
                        <span>Circle Diameter (mm)</span>
                        <span id="grid-count-display" class="text-blue-500 font-mono text-[10px]"></span>
                    </label>
                    <input type="number" id="input-dot-size" value="3.0" step="0.1" class="w-full p-2 border border-slate-300 rounded focus:ring-2 focus:ring-blue-500 focus:outline-none text-slate-700 font-mono">
                    <p class="text-[10px] text-slate-400 mt-1">Standard SS10 rhinestone is ~2.8mm</p>
                </div>
            </div>

            <hr class="border-slate-100">

            <!-- Cylinder calculator -->
            <div class="bg-slate-50 rounded-lg border border-slate-200 p-4 space-y-3">
                <div class="flex items-center gap-2">
                    <i class="fa-solid fa-drum text-blue-500"></i>
                    <label class="text-sm font-semibold text-slate-700">Cylinder → Unrolled</label>
                </div>
                <p class="text-xs text-slate-500">Enter cylinder height and diameter to get the flat (unrolled) rectangle size.</p>
                <div class="grid grid-cols-2 gap-3">
                    <div>
                        <label class="block text-xs text-slate-500 mb-1">Height</label>
                        <input type="number" id="cyl-height" value="3" step="0.01" min="0" class="w-full p-2 border border-slate-300 rounded text-slate-700 font-mono text-sm">
                    </div>
                    <div>
                        <label class="block text-xs text-slate-500 mb-1">Diameter</label>
                        <input type="number" id="cyl-diameter" value="1.5" step="0.01" min="0" class="w-full p-2 border border-slate-300 rounded text-slate-700 font-mono text-sm">
                    </div>
                </div>
                <div class="text-xs font-mono text-slate-600 space-y-1">
                    <div>Unrolled width = π×d: <strong id="unrolled-width">—</strong></div>
                    <div>Unrolled height: <strong id="unrolled-height">—</strong></div>
                </div>
                <div class="flex gap-2">
                    <button type="button" id="cyl-unit-in" class="flex-1 py-1.5 text-xs font-medium rounded border border-slate-200 bg-white text-slate-600 hover:bg-slate-50">in</button>
                    <button type="button" id="cyl-unit-cm" class="flex-1 py-1.5 text-xs font-medium rounded border border-slate-200 bg-white text-slate-600 hover:bg-slate-50">cm</button>
                    <button type="button" id="cyl-unit-mm" class="flex-1 py-1.5 text-xs font-medium rounded border border-slate-200 bg-white text-slate-600 hover:bg-slate-50">mm</button>
                </div>
                <button type="button" id="apply-cyl-to-canvas" class="w-full py-2 bg-blue-600 hover:bg-blue-700 text-white rounded text-sm font-medium transition">
                    <i class="fa-solid fa-arrow-right-to-bracket mr-2"></i> Apply to canvas
                </button>
            </div>
            
            <div class="pt-4">
                <button id="clear-canvas-btn" class="w-full py-2 border border-red-200 text-red-500 rounded hover:bg-red-50 transition text-sm font-medium">
                    <i class="fa-solid fa-trash-can mr-2"></i> Clear Pattern
                </button>
            </div>

        </div>
        
        <div class="p-3 bg-slate-50 text-center text-xs text-slate-400 border-t border-slate-200">
             Pattern Maker v1.3 (SVG)
        </div>
    </aside>

    <!-- Main Canvas Area -->
    <main class="flex-1 relative overflow-hidden flex flex-col">
        <!-- Toolbar -->
        <div class="toolbar-area h-14 bg-white border-b border-slate-200 flex items-center px-4 justify-between shadow-sm z-10">
            <div class="flex items-center gap-6">
                <!-- Zoom Controls -->
                <div class="flex items-center border border-slate-200 rounded bg-slate-50">
                    <button id="zoom-out" class="px-3 py-1.5 hover:bg-slate-200 text-slate-600 border-r border-slate-200"><i class="fa-solid fa-minus"></i></button>
                    <span id="zoom-level" class="px-3 text-xs font-mono text-slate-600 w-16 text-center">100%</span>
                    <button id="zoom-in" class="px-3 py-1.5 hover:bg-slate-200 text-slate-600 border-l border-slate-200"><i class="fa-solid fa-plus"></i></button>
                </div>
                
                <!-- Drawing tools -->
                <div class="flex items-center gap-1 border border-slate-200 rounded bg-slate-50 p-0.5">
                    <button type="button" class="tool-btn active" data-tool="paint" title="Paint"><i class="fa-solid fa-paintbrush"></i></button>
                    <button type="button" class="tool-btn" data-tool="line" title="Line"><i class="fa-solid fa-minus"></i></button>
                    <button type="button" class="tool-btn" data-tool="circle" title="Circle"><i class="fa-regular fa-circle"></i></button>
                    <button type="button" class="tool-btn" data-tool="square" title="Square"><i class="fa-solid fa-square"></i></button>
                    <button type="button" class="tool-btn" data-tool="fill" title="Fill"><i class="fa-solid fa-fill-drip"></i></button>
                    <button type="button" class="tool-btn" data-tool="eraser" title="Eraser"><i class="fa-solid fa-eraser"></i></button>
                    <button type="button" class="tool-btn" data-tool="eyedropper" title="Eyedropper"><i class="fa-solid fa-eyedropper"></i></button>
                </div>
                <div id="brush-width-wrap" class="hidden items-center gap-2">
                    <label id="brush-width-label" class="text-xs text-slate-500 whitespace-nowrap">Brush width:</label>
                    <input type="range" id="brush-width-slider" min="1" max="50" value="1" class="w-24">
                    <input type="number" id="brush-width-input" min="1" max="50" value="1" class="w-12 text-xs font-mono text-slate-600 border border-slate-200 rounded px-1 py-0.5 text-right">
                </div>
            </div>

            <div class="flex gap-2">
                <button type="button" id="save-pattern-btn" class="bg-slate-100 hover:bg-slate-200 text-slate-700 px-3 py-1.5 rounded text-sm font-medium transition flex items-center gap-1.5" title="Save pattern">
                    <i class="fa-solid fa-floppy-disk"></i> Save
                </button>
                <button type="button" id="load-pattern-btn" class="bg-slate-100 hover:bg-slate-200 text-slate-700 px-3 py-1.5 rounded text-sm font-medium transition flex items-center gap-1.5" title="Load pattern">
                    <i class="fa-solid fa-folder-open"></i> Load
                </button>
                <button type="button" id="undo-btn" class="bg-slate-100 hover:bg-slate-200 text-slate-700 px-3 py-1.5 rounded text-sm font-medium transition flex items-center gap-1.5 disabled:opacity-50 disabled:cursor-not-allowed" title="Undo (max 3)">
                    <i class="fa-solid fa-rotate-left"></i> Undo
                </button>
                <button type="button" id="redo-btn" class="bg-slate-100 hover:bg-slate-200 text-slate-700 px-3 py-1.5 rounded text-sm font-medium transition flex items-center gap-1.5 disabled:opacity-50 disabled:cursor-not-allowed" title="Redo (max 3)">
                    <i class="fa-solid fa-rotate-right"></i> Redo
                </button>
                <button id="print-btn" class="bg-slate-100 hover:bg-slate-200 text-slate-700 px-4 py-1.5 rounded text-sm font-medium transition flex items-center gap-2">
                    <i class="fa-solid fa-print"></i> Print
                </button>
                <div class="relative" id="exports-wrap">
                    <button type="button" id="exports-toggle-btn" class="bg-slate-100 hover:bg-slate-200 text-slate-700 px-3 py-1.5 rounded text-sm font-medium transition flex items-center gap-1.5" title="Exports">
                        <i class="fa-solid fa-image"></i> Exports
                    </button>
                    <div id="exports-dropdown" class="hidden absolute top-full left-0 mt-1 py-1 bg-white rounded-lg shadow-lg border border-slate-200 z-50 min-w-[140px]">
                        <button type="button" id="download-svg-btn" class="w-full text-left px-4 py-2 text-sm text-slate-700 hover:bg-slate-50 flex items-center gap-2 rounded-none first:rounded-t-lg" title="Download SVG Vector File">
                            <i class="fa-solid fa-vector-square"></i> SVG
                        </button>
                        <button type="button" id="download-btn" class="w-full text-left px-4 py-2 text-sm text-slate-700 hover:bg-slate-50 flex items-center gap-2 rounded-none last:rounded-b-lg" title="Download PNG">
                            <i class="fa-solid fa-image"></i> PNG
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Viewport -->
        <div class="flex-1 overflow-auto bg-slate-100 relative p-12 canvas-container cursor-grab" id="scroll-container">
            <!-- Navigation instructions overlay (bottom-right of canvas viewport) -->
            <div id="nav-instructions-overlay" class="absolute bottom-4 right-4 flex flex-col gap-1 text-xs text-slate-500 pointer-events-none bg-white/90 backdrop-blur-sm px-3 py-2 rounded-lg border border-slate-200 shadow-sm">
                <span><i class="fa-regular fa-circle-dot"></i> Ctrl+Wheel Zoom · <i class="fa-solid fa-up-down-left-right"></i> Middle-Click Pan</span>
                <span><i class="fa-solid fa-mobile-screen"></i> Pinch to zoom · Two-finger pan</span>
            </div>
            
            <!-- Canvas Wrapper (Scalable) -->
            <div class="relative transition-transform duration-75 origin-top-left" id="canvas-scaler" style="margin-top: 30px; margin-left: 30px;">
                
                <!-- The "Paper" -->
                <div class="relative bg-white shadow-2xl" id="canvas-wrapper">
                    
                    <!-- Top Dimension -->
                    <div class="absolute -top-10 left-0 w-full flex justify-center items-center" style="height: 40px;">
                        <div class="dimension-line" style="left: 0; bottom: 5px; width: 1px; height: 15px;"></div>
                        <div class="dimension-line" style="right: 0; bottom: 5px; width: 1px; height: 15px;"></div>
                        <div class="dimension-line" style="left: 0; right: 0; bottom: 12px; height: 1px;"></div>
                        <div class="dimension-arrow" style="left: -1px; bottom: 8px; transform: rotate(90deg);"></div>
                        <div class="dimension-arrow" style="right: -1px; bottom: 8px; transform: rotate(-90deg);"></div>
                        <span id="dim-text-top" class="dimension-text absolute -top-10 bg-slate-100/80 px-1 rounded">1.37 in</span>
                    </div>

                    <!-- Side Dimension -->
                    <div class="absolute -right-12 top-0 h-full flex flex-col justify-center items-center" style="width: 40px;">
                        <div class="dimension-line" style="top: 0; left: 5px; width: 15px; height: 1px;"></div>
                        <div class="dimension-line" style="bottom: 0; left: 5px; width: 15px; height: 1px;"></div>
                        <div class="dimension-line" style="top: 0; bottom: 0; left: 12px; width: 1px;"></div>
                        <div class="dimension-arrow" style="top: -1px; left: 8px; transform: rotate(180deg);"></div>
                        <div class="dimension-arrow" style="bottom: -1px; left: 8px; transform: rotate(0deg);"></div>
                        <span id="dim-text-side" class="dimension-text absolute -right-16 top-1/2 -translate-y-1/2 bg-slate-100/80 px-1 rounded" style="writing-mode: vertical-rl;">3.69 in</span>
                    </div>

                    <!-- Row Numbers -->
                    <div id="row-numbers" class="absolute top-0 -left-8 w-6 flex flex-col items-end pt-1 pb-1 text-[10px] text-slate-400 font-mono leading-none select-none pointer-events-none h-full">
                        <!-- Populated by JS -->
                    </div>

                    <!-- SVG Drawing Surface -->
                    <!-- Overflow Visible allows circles to hang off the edge while wrapper stays constrained -->
                    <svg id="grid-svg" xmlns="http://www.w3.org/2000/svg" style="overflow: visible; display: block; cursor: crosshair;">
                        <!-- Content injected by JS -->
                    </svg>
                    <!-- Preview overlay (same size as grid-svg, for line/circle/square preview) -->
                    <svg id="preview-svg" xmlns="http://www.w3.org/2000/svg" class="absolute top-0 left-0 pointer-events-none" style="overflow: visible; display: none; width: 100%; height: 100%;">
                        <!-- Preview shapes drawn by JS -->
                    </svg>
                    
                    <!-- Border Overlay (optional UI polish) -->
                    <div id="canvas-ui-border" class="absolute top-0 left-0 w-full h-full border border-slate-200 pointer-events-none"></div>
                </div>
            </div>
        </div>
    </main>

    <!-- Save/Load modal -->
    <div id="save-load-modal" class="modal-overlay" aria-hidden="true">
        <div class="modal-panel p-5" role="dialog" aria-labelledby="modal-title">
            <h2 id="modal-title" class="mb-4">Save pattern</h2>
            <!-- Save mode -->
            <div id="save-load-save-section" class="space-y-3">
                <label class="block text-sm font-medium text-slate-600">Pattern name</label>
                <input type="text" id="save-pattern-name" class="w-full border border-slate-200 rounded-lg px-3 py-2 text-sm" placeholder="My pattern" maxlength="100">
                <div class="flex gap-2 justify-end pt-2">
                    <button type="button" id="modal-cancel-btn" class="px-4 py-2 rounded-lg border border-slate-200 text-slate-600 hover:bg-slate-50 text-sm font-medium">Cancel</button>
                    <button type="button" id="modal-save-btn" class="px-4 py-2 rounded-lg bg-blue-600 text-white hover:bg-blue-700 text-sm font-medium">Save</button>
                </div>
            </div>
            <!-- Load mode -->
            <div id="save-load-load-section" class="hidden">
                <p id="save-load-empty" class="text-sm text-slate-500 py-4 hidden">No saved patterns.</p>
                <ul id="save-load-list" class="save-load-list space-y-2"></ul>
                <div class="flex justify-end pt-3">
                    <button type="button" id="modal-close-load-btn" class="px-4 py-2 rounded-lg border border-slate-200 text-slate-600 hover:bg-slate-50 text-sm font-medium">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden Print Area handled by CSS -->

    <script>
        const state = {
            color: { h: 0, s: 100, v: 100 },
            hex: '#FF0000',
            palette: ['#ef4444', '#f97316', '#f59e0b', '#84cc16', '#10b981', '#06b6d4', '#3b82f6', '#6366f1', '#8b5cf6', '#d946ef', '#f43f5e', '#1f2937', '#9ca3af', '#ffffff'],
            unit: 'in',
            width: 1.37,
            height: 3.69,
            dotSizeMm: 3.0,
            zoom: 1.0,
            cells: {}, // key: "row,col", value: hex
            tool: 'paint',
            brushWidth: 1,
            eraserWidth: 1,
            undoStack: [],
            redoStack: [],
            cylinderUnit: 'in',
            cylinderHeight: 3,
            cylinderDiameter: 1.5,
            
            // Runtime calc
            rows: 0,
            cols: 0,
            wMm: 0,
            hMm: 0,
            gridGeom: null
        };

        const DOM = {
            container: document.getElementById('scroll-container'),
            svg: document.getElementById('grid-svg'),
            scaler: document.getElementById('canvas-scaler'),
            wrapper: document.getElementById('canvas-wrapper'),
            rowNums: document.getElementById('row-numbers'),
            
            // Inputs
            wInput: document.getElementById('input-width'),
            hInput: document.getElementById('input-height'),
            dInput: document.getElementById('input-dot-size'),
            unitBtns: document.querySelectorAll('.unit-btn'),
            
            // Dim text
            dimTop: document.getElementById('dim-text-top'),
            dimSide: document.getElementById('dim-text-side'),
            gridCount: document.getElementById('grid-count-display'),
            
            // Color Picker
            cpSat: document.getElementById('cp-saturation'),
            cpHue: document.getElementById('cp-hue'),
            cpSatThumb: document.getElementById('cp-sat-thumb'),
            cpHueThumb: document.getElementById('cp-hue-thumb'),
            colorPreview: document.getElementById('color-preview'),
            hexInput: document.getElementById('hex-input'),
            paletteContainer: document.getElementById('palette-container'),
            addToPaletteBtn: document.getElementById('add-to-palette'),
            clearPaletteBtn: document.getElementById('clear-palette'),
            
            // Actions
            savePatternBtn: document.getElementById('save-pattern-btn'),
            loadPatternBtn: document.getElementById('load-pattern-btn'),
            undoBtn: document.getElementById('undo-btn'),
            redoBtn: document.getElementById('redo-btn'),
            clearCanvasBtn: document.getElementById('clear-canvas-btn'),
            // Save/Load modal
            saveLoadModal: document.getElementById('save-load-modal'),
            modalTitle: document.getElementById('modal-title'),
            savePatternName: document.getElementById('save-pattern-name'),
            modalCancelBtn: document.getElementById('modal-cancel-btn'),
            modalSaveBtn: document.getElementById('modal-save-btn'),
            saveLoadSaveSection: document.getElementById('save-load-save-section'),
            saveLoadLoadSection: document.getElementById('save-load-load-section'),
            saveLoadEmpty: document.getElementById('save-load-empty'),
            saveLoadList: document.getElementById('save-load-list'),
            modalCloseLoadBtn: document.getElementById('modal-close-load-btn'),
            downloadBtn: document.getElementById('download-btn'),
            downloadSvgBtn: document.getElementById('download-svg-btn'),
            exportsWrap: document.getElementById('exports-wrap'),
            exportsToggleBtn: document.getElementById('exports-toggle-btn'),
            exportsDropdown: document.getElementById('exports-dropdown'),
            printBtn: document.getElementById('print-btn'),
            
            // Zoom
            zoomInBtn: document.getElementById('zoom-in'),
            zoomOutBtn: document.getElementById('zoom-out'),
            zoomLabel: document.getElementById('zoom-level'),
            
            // Tools
            toolBtns: document.querySelectorAll('.tool-btn'),
            brushWidthWrap: document.getElementById('brush-width-wrap'),
            brushWidthLabel: document.getElementById('brush-width-label'),
            brushWidthSlider: document.getElementById('brush-width-slider'),
            brushWidthInput: document.getElementById('brush-width-input'),
            previewSvg: document.getElementById('preview-svg'),
            
            // Cylinder
            cylHeight: document.getElementById('cyl-height'),
            cylDiameter: document.getElementById('cyl-diameter'),
            unrolledWidthEl: document.getElementById('unrolled-width'),
            unrolledHeightEl: document.getElementById('unrolled-height'),
            applyCylToCanvas: document.getElementById('apply-cyl-to-canvas'),
            cylUnitBtns: [document.getElementById('cyl-unit-in'), document.getElementById('cyl-unit-cm'), document.getElementById('cyl-unit-mm')]
        };

        function init() {
            renderPalette();
            setupColorPicker();
            setupGridInputs();
            setupToolbar();
            setupCylinderCalculator();
            setupSVGInteraction();
            setupSaveLoad();
            setupZoom();
            setupPan();
            setupTouchGestures();
            
            updateDimensions();
        }

        /** Get SVG point in mm from mouse event (relative to grid-svg) */
        function svgPointFromEvent(e) {
            return svgPointFromClient(e.clientX, e.clientY);
        }

        /** Get SVG point in mm from client coordinates (for touch) */
        function svgPointFromClient(clientX, clientY) {
            const svg = DOM.svg;
            const pt = svg.createSVGPoint();
            pt.x = clientX;
            pt.y = clientY;
            const mat = svg.getScreenCTM().inverse();
            const t = pt.matrixTransform(mat);
            return { x: t.x, y: t.y };
        }

        /** Get cell key "row,col" at mm point (nearest cell center), or null */
        function getCellKeyAtPoint(xMm, yMm) {
            const g = state.gridGeom;
            if (!g || state.rows === 0 || state.cols === 0) return null;
            const { r, xS, yS } = g;
            let bestKey = null;
            let bestDist = Infinity;
            for (let row = 0; row < state.rows; row++) {
                const rowOffset = (row % 2 !== 0) ? r : 0;
                for (let col = 0; col < state.cols; col++) {
                    const cx = (col * xS) + r + rowOffset;
                    const cy = (row * yS) + r;
                    const dx = xMm - cx, dy = yMm - cy;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < bestDist) {
                        bestDist = dist;
                        bestKey = `${row},${col}`;
                    }
                }
            }
            if (bestDist > r * 1.5) return null;
            return bestKey;
        }

        /** All cell centers as { key, cx, cy } */
        function getAllCellCenters() {
            const g = state.gridGeom;
            if (!g) return [];
            const { r, xS, yS } = g;
            const out = [];
            for (let row = 0; row < state.rows; row++) {
                const rowOffset = (row % 2 !== 0) ? r : 0;
                for (let col = 0; col < state.cols; col++) {
                    const cx = (col * xS) + r + rowOffset;
                    const cy = (row * yS) + r;
                    out.push({ key: `${row},${col}`, cx, cy });
                }
            }
            return out;
        }

        function distPointToSegment(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1, dy = y2 - y1;
            const len = Math.sqrt(dx * dx + dy * dy) || 1e-9;
            const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / (len * len)));
            const projX = x1 + t * dx, projY = y1 + t * dy;
            return Math.sqrt((px - projX) ** 2 + (py - projY) ** 2);
        }

        function getCellsInLine(x1, y1, x2, y2) {
            const g = state.gridGeom;
            if (!g) return [];
            const { r } = g;
            const threshold = r * 0.9;
            const cells = [];
            getAllCellCenters().forEach(({ key, cx, cy }) => {
                if (distPointToSegment(cx, cy, x1, y1, x2, y2) <= threshold) cells.push(key);
            });
            return cells;
        }

        function getCellsInCircle(cx, cy, radiusMm) {
            const centers = getAllCellCenters();
            const cells = [];
            centers.forEach(({ key, cx: ccx, cy: ccy }) => {
                const d = Math.sqrt((cx - ccx) ** 2 + (cy - ccy) ** 2);
                if (d <= radiusMm) cells.push(key);
            });
            return cells;
        }

        function getCellsInRect(x1, y1, x2, y2) {
            const xMin = Math.min(x1, x2), xMax = Math.max(x1, x2);
            const yMin = Math.min(y1, y2), yMax = Math.max(y1, y2);
            const cells = [];
            getAllCellCenters().forEach(({ key, cx, cy }) => {
                if (cx >= xMin && cx <= xMax && cy >= yMin && cy <= yMax) cells.push(key);
            });
            return cells;
        }

        function setupToolbar() {
            DOM.toolBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const tool = btn.dataset.tool;
                    state.tool = tool;
                    DOM.toolBtns.forEach(b => {
                        b.classList.toggle('active', b.dataset.tool === tool);
                    });
                    const showWidth = tool === 'paint' || tool === 'eraser';
                    DOM.brushWidthWrap.classList.toggle('hidden', !showWidth);
                    DOM.brushWidthWrap.classList.toggle('flex', showWidth);
                    DOM.brushWidthLabel.textContent = tool === 'eraser' ? 'Eraser width:' : 'Brush width:';
                    if (tool === 'paint') {
                        DOM.brushWidthSlider.value = state.brushWidth;
                        DOM.brushWidthInput.value = state.brushWidth;
                    } else if (tool === 'eraser') {
                        DOM.brushWidthSlider.value = state.eraserWidth;
                        DOM.brushWidthInput.value = state.eraserWidth;
                    }
                });
            });
            function setBrushWidth(val) {
                val = Math.max(1, Math.min(50, val));
                if (state.tool === 'eraser') {
                    state.eraserWidth = val;
                } else {
                    state.brushWidth = val;
                }
                DOM.brushWidthSlider.value = val;
                DOM.brushWidthInput.value = val;
            }
            DOM.brushWidthSlider.addEventListener('input', () => {
                setBrushWidth(parseInt(DOM.brushWidthSlider.value, 10) || 1);
            });
            DOM.brushWidthInput.addEventListener('input', () => {
                setBrushWidth(parseInt(DOM.brushWidthInput.value, 10) || 1);
            });
            DOM.brushWidthInput.value = state.brushWidth;
            const showWidth = state.tool === 'paint' || state.tool === 'eraser';
            DOM.brushWidthWrap.classList.toggle('hidden', !showWidth);
            DOM.brushWidthWrap.classList.toggle('flex', showWidth);
            DOM.brushWidthLabel.textContent = state.tool === 'eraser' ? 'Eraser width:' : 'Brush width:';
        }

        function setupCylinderCalculator() {
            function cylUnitToMm(val) {
                if (state.cylinderUnit === 'in') return val * 25.4;
                if (state.cylinderUnit === 'cm') return val * 10;
                return val;
            }
            function mmToCylUnit(mm) {
                if (state.cylinderUnit === 'in') return mm / 25.4;
                if (state.cylinderUnit === 'cm') return mm / 10;
                return mm;
            }
            function updateUnrolled() {
                const h = parseFloat(DOM.cylHeight.value) || 0;
                const d = parseFloat(DOM.cylDiameter.value) || 0;
                state.cylinderHeight = h;
                state.cylinderDiameter = d;
                const hMm = cylUnitToMm(h), dMm = cylUnitToMm(d);
                const widthMm = Math.PI * dMm;
                DOM.unrolledWidthEl.textContent = mmToCylUnit(widthMm).toFixed(3) + ' ' + state.cylinderUnit;
                DOM.unrolledHeightEl.textContent = h.toFixed(3) + ' ' + state.cylinderUnit;
            }
            DOM.cylHeight.addEventListener('input', updateUnrolled);
            DOM.cylDiameter.addEventListener('input', updateUnrolled);
            DOM.cylUnitBtns.forEach((btn, i) => {
                const u = ['in', 'cm', 'mm'][i];
                btn.addEventListener('click', () => {
                    state.cylinderUnit = u;
                    DOM.cylUnitBtns.forEach((b, j) => {
                        b.classList.toggle('bg-blue-100', j === i);
                        b.classList.toggle('border-blue-400', j === i);
                    });
                    updateUnrolled();
                });
            });
            DOM.cylUnitBtns[0].classList.add('bg-blue-100', 'border-blue-400');
            DOM.applyCylToCanvas.addEventListener('click', () => {
                const h = parseFloat(DOM.cylHeight.value) || 0;
                const d = parseFloat(DOM.cylDiameter.value) || 0;
                const hMm = cylUnitToMm(h), dMm = cylUnitToMm(d);
                const widthMm = Math.PI * dMm;
                if (state.unit === 'in') {
                    state.width = widthMm / 25.4;
                    state.height = hMm / 25.4;
                } else if (state.unit === 'cm') {
                    state.width = widthMm / 10;
                    state.height = hMm / 10;
                } else {
                    state.width = widthMm;
                    state.height = hMm;
                }
                DOM.wInput.value = parseFloat(state.width.toFixed(4));
                DOM.hInput.value = parseFloat(state.height.toFixed(4));
                updateDimensions();
            });
            updateUnrolled();
        }

        const MAX_UNDO_REDO = 3;

        function pushUndo() {
            state.redoStack = [];
            state.undoStack.push({ ...state.cells });
            if (state.undoStack.length > MAX_UNDO_REDO) state.undoStack.shift();
            updateUndoRedoButtons();
        }

        function undo() {
            if (state.undoStack.length === 0) return;
            state.redoStack.push({ ...state.cells });
            if (state.redoStack.length > MAX_UNDO_REDO) state.redoStack.shift();
            state.cells = state.undoStack.pop();
            updateDimensions();
            updateUndoRedoButtons();
        }

        function redo() {
            if (state.redoStack.length === 0) return;
            state.undoStack.push({ ...state.cells });
            if (state.undoStack.length > MAX_UNDO_REDO) state.undoStack.shift();
            state.cells = state.redoStack.pop();
            updateDimensions();
            updateUndoRedoButtons();
        }

        function updateUndoRedoButtons() {
            DOM.undoBtn.disabled = state.undoStack.length === 0;
            DOM.redoBtn.disabled = state.redoStack.length === 0;
        }

        /**
         * CORE LOGIC
         */
        function updateDimensions() {
            // 1. Calculate physical dimensions in MM
            let wMm, hMm;
            if (state.unit === 'in') {
                wMm = state.width * 25.4;
                hMm = state.height * 25.4;
            } else if (state.unit === 'cm') {
                wMm = state.width * 10;
                hMm = state.height * 10;
            } else {
                wMm = state.width;
                hMm = state.height;
            }
            
            state.wMm = wMm;
            state.hMm = hMm;

            // 2. Calculate Grid Metrics
            const diameterMm = state.dotSizeMm;
            const radiusMm = diameterMm / 2;
            const xSpacingMm = diameterMm; 
            const ySpacingMm = diameterMm * 0.8660254; 

            // Calculate how many rows/cols technically cover the space
            // We ensure we cover the whole area, letting circles overflow
            state.cols = Math.ceil(wMm / xSpacingMm);
            // Simple check to ensure we don't leave a gap if alignment is slightly off
            if( (state.cols * xSpacingMm) < wMm ) state.cols++; 

            state.rows = Math.ceil(hMm / ySpacingMm);
            if( (state.rows * ySpacingMm) < hMm ) state.rows++;

            DOM.gridCount.textContent = `~${state.cols}x${state.rows} dots`;
            DOM.dimTop.textContent = `${state.width} ${state.unit}`;
            DOM.dimSide.textContent = `${state.height} ${state.unit}`;

            // 3. Set Wrapper Size (The "Paper")
            // We need to map MM to CSS pixels. 
            // 96 DPI = 3.7795 px/mm.
            // We'll use a standard display scale factor.
            const cssScale = 3.78; 
            
            DOM.wrapper.style.width = `${wMm * cssScale}px`;
            DOM.wrapper.style.height = `${hMm * cssScale}px`;

            // 4. Render SVG
            // SVG Viewbox uses MM units directly for simplicity
            DOM.svg.setAttribute('viewBox', `0 0 ${wMm} ${hMm}`);
            // SVG width/height matches CSS wrapper 1:1 to avoid browser scaling weirdness
            DOM.svg.setAttribute('width', `${wMm * cssScale}px`);
            DOM.svg.setAttribute('height', `${hMm * cssScale}px`);

            state.gridGeom = { d: diameterMm, r: radiusMm, xS: xSpacingMm, yS: ySpacingMm };
            renderSVGContent(diameterMm, radiusMm, xSpacingMm, ySpacingMm);
            
            // Update row markers
            renderRowNumbers(state.rows, ySpacingMm * cssScale, radiusMm * cssScale);
            
            // Keep preview SVG in sync
            DOM.previewSvg.setAttribute('viewBox', `0 0 ${wMm} ${hMm}`);
            DOM.previewSvg.setAttribute('width', `${wMm * cssScale}px`);
            DOM.previewSvg.setAttribute('height', `${hMm * cssScale}px`);
        }

        function renderSVGContent(d, r, xS, yS) {
            let svgContent = '';
            
            // Background Rect (White fill for export)
            svgContent += `<rect x="0" y="0" width="${state.wMm}" height="${state.hMm}" fill="#ffffff" stroke="none" />`;

            for (let row = 0; row < state.rows; row++) {
                const rowOffset = (row % 2 !== 0) ? r : 0;
                
                for (let col = 0; col < state.cols; col++) {
                    const cx = (col * xS) + r + rowOffset;
                    const cy = (row * yS) + r;
                    
                    // Optimization: Skip if center is waaay outside (visual polish)
                    // But user asked for "not cut off", so we include edge cases.
                    
                    const key = `${row},${col}`;
                    const fill = state.cells[key] || '#f8fafc'; // Default light slate
                    const stroke = state.cells[key] ? 'rgba(0,0,0,0.1)' : '#cbd5e1';
                    const strokeWidth = state.cells[key] ? 0.1 : 0.1; // MM units

                    svgContent += `<circle 
                        id="cell-${row}-${col}"
                        data-key="${key}"
                        cx="${cx}" 
                        cy="${cy}" 
                        r="${r - 0.1}" 
                        fill="${fill}" 
                        stroke="${stroke}" 
                        stroke-width="${strokeWidth}"
                    />`;
                }
            }
            
            DOM.svg.innerHTML = svgContent;
        }

        function renderRowNumbers(count, rowHeightPx, radiusPx) {
            DOM.rowNums.innerHTML = '';
            for(let i=0; i<count; i++) {
                const yPos = (i * rowHeightPx) + radiusPx;
                
                const el = document.createElement('div');
                el.innerText = i + 1;
                el.style.position = 'absolute';
                el.style.top = `${yPos}px`;
                el.style.transform = 'translateY(-50%)';
                el.style.width = '100%';
                el.style.textAlign = 'right';
                DOM.rowNums.appendChild(el);
            }
        }

        /** All cell keys within brush width (square in row,col) centered on key */
        function getKeysInBrush(key, width) {
            const [row, col] = key.split(',').map(Number);
            const rad = Math.floor((width - 1) / 2);
            const keys = [];
            for (let r = row - rad; r <= row + rad; r++) {
                for (let c = col - rad; c <= col + rad; c++) {
                    if (r >= 0 && r < state.rows && c >= 0 && c < state.cols)
                        keys.push(`${r},${c}`);
                }
            }
            return keys;
        }

        /** Neighbors for honeycomb grid (row,col) */
        function getNeighbors(row, col) {
            const out = [];
            const even = row % 2 === 0;
            const offsets = even
                ? [[-1,-1],[-1,0],[0,-1],[0,1],[1,-1],[1,0]]
                : [[-1,0],[-1,1],[0,-1],[0,1],[1,0],[1,1]];
            offsets.forEach(([dr, dc]) => {
                const r = row + dr, c = col + dc;
                if (r >= 0 && r < state.rows && c >= 0 && c < state.cols) out.push(`${r},${c}`);
            });
            return out;
        }

        /** Flood fill from key, replace replaceColor with state.hex (entire connected region). */
        function floodFill(startKey) {
            pushUndo();
            const replaceColor = (state.cells[startKey] === undefined) ? '#f8fafc' : state.cells[startKey];
            const fillColor = state.hex;
            if (replaceColor === fillColor) return;
            const filled = new Set();
            const queue = [startKey];
            filled.add(startKey);
            while (queue.length) {
                const key = queue.shift();
                const [row, col] = key.split(',').map(Number);
                getNeighbors(row, col).forEach(nkey => {
                    if (filled.has(nkey)) return;
                    const cellColor = state.cells[nkey] === undefined ? '#f8fafc' : state.cells[nkey];
                    if (cellColor !== replaceColor) return;
                    filled.add(nkey);
                    queue.push(nkey);
                });
            }
            filled.forEach(key => {
                state.cells[key] = fillColor;
            });
            updateDimensions();
        }

        /**
         * INTERACTION (SVG)
         */
        function setupSVGInteraction() {
            let isPainting = false;
            let isErasing = false;
            let drawStart = null;
            let lastTouchPt = null;

            function paintCell(target) {
                if (target.tagName === 'circle') {
                    const key = target.dataset.key;
                    if (!key) return;
                    const isEraserTool = state.tool === 'eraser';
                    const isErasingMode = isEraserTool || isErasing;
                    const width = isEraserTool ? state.eraserWidth : state.brushWidth;
                    const keys = (state.tool === 'paint' || state.tool === 'eraser') && width >= 1
                        ? getKeysInBrush(key, width)
                        : [key];
                    keys.forEach(k => {
                        const el = k === key ? target : DOM.svg.querySelector(`circle[data-key="${k}"]`);
                        if (!el) return;
                        if (isErasingMode) {
                            delete state.cells[k];
                            el.setAttribute('fill', '#f8fafc');
                            el.setAttribute('stroke', '#cbd5e1');
                        } else {
                            state.cells[k] = state.hex;
                            el.setAttribute('fill', state.hex);
                            el.setAttribute('stroke', 'rgba(0,0,0,0.1)');
                        }
                    });
                    if (keys.length > 1) updateDimensions();
                }
            }

            function applyCellsToState(keys) {
                keys.forEach(key => {
                    state.cells[key] = state.hex;
                });
                updateDimensions();
            }

            function clearPreview() {
                DOM.previewSvg.innerHTML = '';
                DOM.previewSvg.style.display = 'none';
            }

            function updatePreviewShape(tool, x1, y1, x2, y2) {
                DOM.previewSvg.innerHTML = '';
                DOM.previewSvg.style.display = 'block';
                const vb = DOM.previewSvg.getAttribute('viewBox');
                if (!vb) return;
                const stroke = state.hex;
                const strokeWidth = Math.max(0.3, state.gridGeom ? state.gridGeom.d * 0.15 : 0.5);
                if (tool === 'line') {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x1); line.setAttribute('y1', y1);
                    line.setAttribute('x2', x2); line.setAttribute('y2', y2);
                    line.setAttribute('stroke', stroke);
                    line.setAttribute('stroke-width', strokeWidth);
                    line.setAttribute('stroke-linecap', 'round');
                    DOM.previewSvg.appendChild(line);
                } else if (tool === 'circle') {
                    const cx = (x1 + x2) / 2, cy = (y1 + y2) / 2;
                    const r = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) / 2;
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', cx); circle.setAttribute('cy', cy);
                    circle.setAttribute('r', Math.max(0.1, r));
                    circle.setAttribute('fill', 'none');
                    circle.setAttribute('stroke', stroke);
                    circle.setAttribute('stroke-width', strokeWidth);
                    DOM.previewSvg.appendChild(circle);
                } else if (tool === 'square') {
                    const x = Math.min(x1, x2), y = Math.min(y1, y2);
                    const w = Math.abs(x2 - x1), h = Math.abs(y2 - y1);
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', x); rect.setAttribute('y', y);
                    rect.setAttribute('width', w); rect.setAttribute('height', h);
                    rect.setAttribute('fill', 'none');
                    rect.setAttribute('stroke', stroke);
                    rect.setAttribute('stroke-width', strokeWidth);
                    DOM.previewSvg.appendChild(rect);
                }
            }

            DOM.svg.addEventListener('mousedown', (e) => {
                if (e.button !== 0 && e.button !== 2) return;
                const pt = svgPointFromEvent(e);
                if (state.tool === 'fill') {
                    const key = getCellKeyAtPoint(pt.x, pt.y);
                    if (key) floodFill(key);
                    return;
                }
                if (state.tool === 'eyedropper' && e.target.tagName === 'circle') {
                    const key = e.target.dataset.key;
                    if (key) {
                        const hex = state.cells[key] !== undefined ? state.cells[key] : '#f8fafc';
                        if (typeof window.setColorFromHex === 'function') window.setColorFromHex(hex);
                    }
                    return;
                }
                if (state.tool === 'line' || state.tool === 'circle' || state.tool === 'square') {
                    drawStart = { x: pt.x, y: pt.y };
                    updatePreviewShape(state.tool, pt.x, pt.y, pt.x, pt.y);
                    return;
                }
                isPainting = true;
                isErasing = (e.button === 2);
                if (state.tool === 'paint' || state.tool === 'eraser') pushUndo();
                paintCell(e.target);
            });

            window.addEventListener('mousemove', (e) => {
                if (drawStart && (state.tool === 'line' || state.tool === 'circle' || state.tool === 'square')) {
                    const pt = svgPointFromEvent(e);
                    updatePreviewShape(state.tool, drawStart.x, drawStart.y, pt.x, pt.y);
                }
            });

            window.addEventListener('mouseup', (e) => {
                if (e.button !== 0) return;
                if (drawStart && (state.tool === 'line' || state.tool === 'circle' || state.tool === 'square')) {
                    const pt = svgPointFromEvent(e);
                    let keys = [];
                    if (state.tool === 'line') keys = getCellsInLine(drawStart.x, drawStart.y, pt.x, pt.y);
                    else if (state.tool === 'circle') {
                        const cx = (drawStart.x + pt.x) / 2, cy = (drawStart.y + pt.y) / 2;
                        const r = Math.sqrt((pt.x - drawStart.x) ** 2 + (pt.y - drawStart.y) ** 2) / 2;
                        keys = getCellsInCircle(cx, cy, r);
                    } else keys = getCellsInRect(drawStart.x, drawStart.y, pt.x, pt.y);
                    pushUndo();
                    applyCellsToState(keys);
                    clearPreview();
                    drawStart = null;
                }
                isPainting = false;
                isErasing = false;
            });

            DOM.svg.addEventListener('mouseleave', () => {
                if (drawStart) {
                    clearPreview();
                    drawStart = null;
                }
            });

            DOM.svg.addEventListener('mouseover', (e) => {
                if (isPainting && (state.tool === 'paint' || state.tool === 'eraser')) {
                    paintCell(e.target);
                }
            });
            
            DOM.svg.addEventListener('contextmenu', e => e.preventDefault());
            
            function handleTouch(e) {
                e.preventDefault();
                const touch = e.touches[0];
                if (!touch) return;
                const target = document.elementFromPoint(touch.clientX, touch.clientY);
                if (target && target.tagName === 'circle' && DOM.svg.contains(target)) {
                    if (state.tool === 'eyedropper') {
                        const key = target.dataset.key;
                        if (key) {
                            const hex = state.cells[key] !== undefined ? state.cells[key] : '#f8fafc';
                            if (typeof window.setColorFromHex === 'function') window.setColorFromHex(hex);
                        }
                        return;
                    }
                    paintCell(target);
                }
            }
            
            DOM.svg.addEventListener('touchstart', (e) => {
                if (e.touches.length > 1) return;
                const touch = e.touches[0];
                const pt = svgPointFromClient(touch.clientX, touch.clientY);
                if (state.tool === 'fill') {
                    e.preventDefault();
                    const key = getCellKeyAtPoint(pt.x, pt.y);
                    if (key) floodFill(key);
                    return;
                }
                if (state.tool === 'line' || state.tool === 'circle' || state.tool === 'square') {
                    e.preventDefault();
                    drawStart = { x: pt.x, y: pt.y };
                    lastTouchPt = { x: pt.x, y: pt.y };
                    updatePreviewShape(state.tool, pt.x, pt.y, pt.x, pt.y);
                    return;
                }
                if (state.tool === 'eyedropper') {
                    handleTouch(e);
                    return;
                }
                isPainting = true;
                isErasing = false;
                if (state.tool === 'paint' || state.tool === 'eraser') pushUndo();
                handleTouch(e);
            }, {passive: false});
            
            DOM.svg.addEventListener('touchmove', (e) => {
                if (e.touches.length > 1) return;
                const touch = e.touches[0];
                if (drawStart && (state.tool === 'line' || state.tool === 'circle' || state.tool === 'square')) {
                    e.preventDefault();
                    const pt = svgPointFromClient(touch.clientX, touch.clientY);
                    lastTouchPt = pt;
                    updatePreviewShape(state.tool, drawStart.x, drawStart.y, pt.x, pt.y);
                    return;
                }
                if (isPainting) {
                    handleTouch(e);
                }
            }, {passive: false});
            
            DOM.svg.addEventListener('touchend', (e) => {
                if (e.touches.length > 1) return;
                if (drawStart && (state.tool === 'line' || state.tool === 'circle' || state.tool === 'square') && e.changedTouches.length) {
                    const end = e.changedTouches[0];
                    const pt = lastTouchPt || svgPointFromClient(end.clientX, end.clientY);
                    let keys = [];
                    if (state.tool === 'line') keys = getCellsInLine(drawStart.x, drawStart.y, pt.x, pt.y);
                    else if (state.tool === 'circle') {
                        const cx = (drawStart.x + pt.x) / 2, cy = (drawStart.y + pt.y) / 2;
                        const r = Math.sqrt((pt.x - drawStart.x) ** 2 + (pt.y - drawStart.y) ** 2) / 2;
                        keys = getCellsInCircle(cx, cy, r);
                    } else keys = getCellsInRect(drawStart.x, drawStart.y, pt.x, pt.y);
                    pushUndo();
                    applyCellsToState(keys);
                    clearPreview();
                    drawStart = null;
                    lastTouchPt = null;
                }
                if (e.touches.length === 0) {
                    isPainting = false;
                    isErasing = false;
                }
            }, {passive: false});
            
            DOM.svg.addEventListener('touchcancel', (e) => {
                if (e.touches.length === 0) {
                    drawStart = null;
                    lastTouchPt = null;
                    isPainting = false;
                    isErasing = false;
                    clearPreview();
                }
            }, {passive: false});
        }

        /**
         * EXPORT
         */
        function setupExport() {
            // Exports dropdown: toggle on button, close on outside click
            DOM.exportsToggleBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                DOM.exportsDropdown.classList.toggle('hidden');
            });
            document.addEventListener('click', (e) => {
                if (!DOM.exportsWrap.contains(e.target)) DOM.exportsDropdown.classList.add('hidden');
            });

            // 1. SVG Export (Vector)
            DOM.downloadSvgBtn.addEventListener('click', () => {
                DOM.exportsDropdown.classList.add('hidden');
                const svgData = DOM.svg.outerHTML;
                const blob = new Blob([svgData], {type: 'image/svg+xml'});
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = `pattern_${state.width}${state.unit}_${state.height}${state.unit}.svg`;
                link.href = url;
                link.click();
            });

            // 2. PNG Export (High Res)
            DOM.downloadBtn.addEventListener('click', () => {
                DOM.exportsDropdown.classList.add('hidden');
                const svgData = new XMLSerializer().serializeToString(DOM.svg);
                const img = new Image();
                const scale = 3; // 3x resolution
                
                // Create a canvas to draw the SVG
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                const wPx = state.wMm * 3.78 * scale;
                const hPx = state.hMm * 3.78 * scale;
                
                canvas.width = wPx;
                canvas.height = hPx;
                
                img.onload = () => {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, wPx, hPx);
                    ctx.drawImage(img, 0, 0, wPx, hPx);
                    
                    const link = document.createElement('a');
                    link.download = `pattern_${state.width}${state.unit}_${state.height}${state.unit}.png`;
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                };
                
                // Load SVG blob
                const blob = new Blob([svgData], {type: 'image/svg+xml;charset=utf-8'});
                const url = URL.createObjectURL(blob);
                img.src = url;
            });
            
            // 3. Print
            DOM.printBtn.addEventListener('click', () => {
                window.print();
            });
        }


        /**
         * Save/Load patterns (IndexedDB + modal)
         */
        const DB_NAME = 'beadpattern-db';
        const STORE_NAME = 'patterns';

        function openDB() {
            return new Promise((resolve, reject) => {
                const req = indexedDB.open(DB_NAME, 1);
                req.onerror = () => reject(req.error);
                req.onsuccess = () => resolve(req.result);
                req.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        const store = db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                        store.createIndex('createdAt', 'createdAt', { unique: false });
                    }
                };
            });
        }

        function savePatternToDB(name) {
            const trimmed = (name || '').trim() || 'Untitled pattern';
            const record = {
                id: Date.now(),
                name: trimmed,
                width: state.width,
                height: state.height,
                unit: state.unit,
                dotSizeMm: state.dotSizeMm,
                cells: { ...state.cells },
                createdAt: Date.now()
            };
            return openDB().then(db => {
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(STORE_NAME, 'readwrite');
                    tx.objectStore(STORE_NAME).put(record);
                    tx.oncomplete = () => resolve();
                    tx.onerror = () => reject(tx.error);
                });
            });
        }

        function getAllPatterns() {
            return openDB().then(db => {
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(STORE_NAME, 'readonly');
                    const req = tx.objectStore(STORE_NAME).getAll();
                    req.onsuccess = () => resolve((req.result || []).sort((a, b) => (b.createdAt || b.id) - (a.createdAt || a.id)));
                    req.onerror = () => reject(req.error);
                });
            });
        }

        function getPattern(id) {
            return openDB().then(db => {
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(STORE_NAME, 'readonly');
                    const req = tx.objectStore(STORE_NAME).get(id);
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                });
            });
        }

        function updatePatternName(id, newName) {
            const trimmed = (newName || '').trim();
            if (!trimmed) return Promise.resolve();
            return getPattern(id).then(p => {
                if (!p) return;
                p.name = trimmed;
                return openDB().then(db => {
                    return new Promise((resolve, reject) => {
                        const tx = db.transaction(STORE_NAME, 'readwrite');
                        tx.objectStore(STORE_NAME).put(p);
                        tx.oncomplete = () => resolve();
                        tx.onerror = () => reject(tx.error);
                    });
                });
            });
        }

        function deletePattern(id) {
            return openDB().then(db => {
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(STORE_NAME, 'readwrite');
                    tx.objectStore(STORE_NAME).delete(id);
                    tx.oncomplete = () => resolve();
                    tx.onerror = () => reject(tx.error);
                });
            });
        }

        function openSaveModal() {
            DOM.modalTitle.textContent = 'Save pattern';
            DOM.saveLoadSaveSection.classList.remove('hidden');
            DOM.saveLoadLoadSection.classList.add('hidden');
            DOM.savePatternName.value = '';
            DOM.savePatternName.placeholder = 'My pattern';
            DOM.saveLoadModal.classList.add('open');
            DOM.saveLoadModal.setAttribute('aria-hidden', 'false');
            setTimeout(() => DOM.savePatternName.focus(), 100);
        }

        function openLoadModal() {
            DOM.modalTitle.textContent = 'Load pattern';
            DOM.saveLoadSaveSection.classList.add('hidden');
            DOM.saveLoadLoadSection.classList.remove('hidden');
            DOM.saveLoadModal.classList.add('open');
            DOM.saveLoadModal.setAttribute('aria-hidden', 'false');
            renderLoadList();
        }

        function closeSaveLoadModal() {
            DOM.saveLoadModal.classList.remove('open');
            DOM.saveLoadModal.setAttribute('aria-hidden', 'true');
        }

        function renderLoadList() {
            DOM.saveLoadList.innerHTML = '';
            getAllPatterns().then(list => {
                if (list.length === 0) {
                    DOM.saveLoadEmpty.classList.remove('hidden');
                    return;
                }
                DOM.saveLoadEmpty.classList.add('hidden');
                list.forEach(p => {
                    const li = document.createElement('li');
                    li.className = 'flex items-center gap-2 py-2 px-3 rounded-lg border border-slate-100 hover:bg-slate-50';
                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'flex-1 text-sm text-slate-700 truncate min-w-0';
                    nameSpan.textContent = p.name;
                    const renameBtn = document.createElement('button');
                    renameBtn.type = 'button';
                    renameBtn.className = 'px-2 py-1 text-xs rounded border border-slate-200 text-slate-600 hover:bg-slate-100 shrink-0';
                    renameBtn.innerHTML = '<i class="fa-solid fa-pen"></i>';
                    renameBtn.title = 'Rename';
                    renameBtn.addEventListener('click', () => {
                        const newName = prompt('Rename pattern:', p.name);
                        if (newName != null && newName.trim()) {
                            updatePatternName(p.id, newName.trim()).then(() => renderLoadList());
                        }
                    });
                    const loadBtn = document.createElement('button');
                    loadBtn.type = 'button';
                    loadBtn.className = 'px-2 py-1 text-xs rounded bg-blue-600 text-white hover:bg-blue-700 shrink-0';
                    loadBtn.textContent = 'Load';
                    loadBtn.addEventListener('click', () => {
                        getPattern(p.id).then(rec => {
                            if (!rec) return;
                            state.width = rec.width;
                            state.height = rec.height;
                            state.unit = rec.unit;
                            state.dotSizeMm = rec.dotSizeMm != null ? rec.dotSizeMm : 3;
                            state.cells = rec.cells ? { ...rec.cells } : {};
                            state.undoStack = [];
                            state.redoStack = [];
                            DOM.wInput.value = parseFloat(state.width.toFixed(2));
                            DOM.hInput.value = parseFloat(state.height.toFixed(2));
                            DOM.dInput.value = state.dotSizeMm;
                            updateDimensions();
                            updateUndoRedoButtons();
                            closeSaveLoadModal();
                        });
                    });
                    const delBtn = document.createElement('button');
                    delBtn.type = 'button';
                    delBtn.className = 'px-2 py-1 text-xs rounded border border-red-200 text-red-600 hover:bg-red-50 shrink-0';
                    delBtn.innerHTML = '<i class="fa-solid fa-trash"></i>';
                    delBtn.title = 'Delete';
                    delBtn.addEventListener('click', () => {
                        if (confirm('Delete this pattern?')) {
                            deletePattern(p.id).then(() => renderLoadList());
                        }
                    });
                    li.appendChild(nameSpan);
                    li.appendChild(renameBtn);
                    li.appendChild(loadBtn);
                    li.appendChild(delBtn);
                    DOM.saveLoadList.appendChild(li);
                });
            }).catch(() => {
                DOM.saveLoadEmpty.classList.remove('hidden');
                DOM.saveLoadEmpty.textContent = 'Could not load patterns.';
            });
        }

        function setupSaveLoad() {
            DOM.savePatternBtn.addEventListener('click', openSaveModal);
            DOM.loadPatternBtn.addEventListener('click', openLoadModal);
            DOM.modalCancelBtn.addEventListener('click', closeSaveLoadModal);
            DOM.modalCloseLoadBtn.addEventListener('click', closeSaveLoadModal);
            DOM.saveLoadModal.addEventListener('click', (e) => {
                if (e.target === DOM.saveLoadModal) closeSaveLoadModal();
            });
            DOM.modalSaveBtn.addEventListener('click', () => {
                const name = DOM.savePatternName.value.trim() || 'Untitled pattern';
                savePatternToDB(name).then(() => {
                    closeSaveLoadModal();
                }).catch(() => alert('Could not save pattern.'));
            });
            DOM.savePatternName.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') DOM.modalSaveBtn.click();
                if (e.key === 'Escape') closeSaveLoadModal();
            });
        }

        /**
         * UTILS & SETUP
         */
        function setupZoom() {
            function setZoom(z) {
                state.zoom = Math.max(0.2, Math.min(5.0, z));
                DOM.scaler.style.transform = `scale(${state.zoom})`;
                DOM.zoomLabel.textContent = `${Math.round(state.zoom * 100)}%`;
            }

            DOM.zoomInBtn.addEventListener('click', () => setZoom(state.zoom + 0.1));
            DOM.zoomOutBtn.addEventListener('click', () => setZoom(state.zoom - 0.1));
            
            DOM.container.addEventListener('wheel', (e) => {
                if(e.ctrlKey) {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? -0.1 : 0.1;
                    setZoom(state.zoom + delta);
                }
            }, { passive: false });
        }

        function setupPan() {
            let isPanning = false;
            let startX, startY, scrollLeft, scrollTop;

            DOM.container.addEventListener('mousedown', (e) => {
                if (e.button === 1) {
                    e.preventDefault();
                    isPanning = true;
                    DOM.container.classList.add('cursor-grabbing');
                    startX = e.pageX - DOM.container.offsetLeft;
                    startY = e.pageY - DOM.container.offsetTop;
                    scrollLeft = DOM.container.scrollLeft;
                    scrollTop = DOM.container.scrollTop;
                }
            });

            window.addEventListener('mousemove', (e) => {
                if (!isPanning) return;
                e.preventDefault();
                const x = e.pageX - DOM.container.offsetLeft;
                const y = e.pageY - DOM.container.offsetTop;
                const walkX = (x - startX) * 1.5;
                const walkY = (y - startY) * 1.5;
                DOM.container.scrollLeft = scrollLeft - walkX;
                DOM.container.scrollTop = scrollTop - walkY;
            });

            window.addEventListener('mouseup', (e) => {
                if (isPanning && e.button === 1) {
                    isPanning = false;
                    DOM.container.classList.remove('cursor-grabbing');
                }
            });
        }

        /** Pinch-to-zoom and two-finger pan on canvas container (touch devices) */
        function setupTouchGestures() {
            let pinchState = null;

            function getTouchCenter(touches) {
                const t0 = touches[0], t1 = touches[1];
                return {
                    clientX: (t0.clientX + t1.clientX) / 2,
                    clientY: (t0.clientY + t1.clientY) / 2
                };
            }

            function getTouchDistance(touches) {
                const t0 = touches[0], t1 = touches[1];
                return Math.hypot(t1.clientX - t0.clientX, t1.clientY - t0.clientY);
            }

            function setZoom(z) {
                state.zoom = Math.max(0.2, Math.min(5.0, z));
                DOM.scaler.style.transform = `scale(${state.zoom})`;
                DOM.zoomLabel.textContent = `${Math.round(state.zoom * 100)}%`;
            }

            DOM.container.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    const rect = DOM.container.getBoundingClientRect();
                    const center = getTouchCenter(e.touches);
                    pinchState = {
                        initialDistance: getTouchDistance(e.touches),
                        initialZoom: state.zoom,
                        initialScrollLeft: DOM.container.scrollLeft,
                        initialScrollTop: DOM.container.scrollTop,
                        initialCenterX: center.clientX,
                        initialCenterY: center.clientY
                    };
                }
            }, { passive: false });

            DOM.container.addEventListener('touchmove', (e) => {
                if (e.touches.length === 2 && pinchState) {
                    e.preventDefault();
                    const distance = getTouchDistance(e.touches);
                    const center = getTouchCenter(e.touches);
                    const zoomRatio = distance / pinchState.initialDistance;
                    const newZoom = Math.max(0.2, Math.min(5.0, pinchState.initialZoom * zoomRatio));
                    setZoom(newZoom);
                    DOM.container.scrollLeft = pinchState.initialScrollLeft - (center.clientX - pinchState.initialCenterX);
                    DOM.container.scrollTop = pinchState.initialScrollTop - (center.clientY - pinchState.initialCenterY);
                }
            }, { passive: false });

            DOM.container.addEventListener('touchend', (e) => {
                if (e.touches.length < 2) pinchState = null;
            }, { passive: false });

            DOM.container.addEventListener('touchcancel', () => {
                pinchState = null;
            }, { passive: false });
        }

        function setupGridInputs() {
            DOM.unitBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    DOM.unitBtns.forEach(b => {
                        b.classList.remove('bg-white', 'shadow-sm', 'text-slate-800');
                        b.classList.add('text-slate-500');
                    });
                    btn.classList.add('bg-white', 'shadow-sm', 'text-slate-800');
                    btn.classList.remove('text-slate-500');
                    
                    const oldUnit = state.unit;
                    const newUnit = btn.dataset.unit;
                    
                    if (oldUnit !== newUnit) {
                        state.width = convertUnit(state.width, oldUnit, newUnit);
                        state.height = convertUnit(state.height, oldUnit, newUnit);
                        state.unit = newUnit;
                        
                        DOM.wInput.value = parseFloat(state.width.toFixed(2));
                        DOM.hInput.value = parseFloat(state.height.toFixed(2));
                        updateDimensions();
                    }
                });
            });

            function handleDimChange() {
                state.width = parseFloat(DOM.wInput.value) || 0;
                state.height = parseFloat(DOM.hInput.value) || 0;
                state.dotSizeMm = parseFloat(DOM.dInput.value) || 3;
                updateDimensions();
            }

            DOM.wInput.addEventListener('input', handleDimChange);
            DOM.hInput.addEventListener('input', handleDimChange);
            DOM.dInput.addEventListener('input', handleDimChange);
            
            DOM.clearCanvasBtn.addEventListener('click', () => {
                if(confirm('Clear entire pattern?')) {
                    pushUndo();
                    state.cells = {};
                    updateDimensions(); // re-render
                }
            });

            DOM.undoBtn.addEventListener('click', undo);
            DOM.redoBtn.addEventListener('click', redo);
            updateUndoRedoButtons();
            
            setupExport();
        }

        function convertUnit(val, from, to) {
            let mm = 0;
            if (from === 'in') mm = val * 25.4;
            else if (from === 'cm') mm = val * 10;
            else mm = val;
            
            if (to === 'in') return mm / 25.4;
            if (to === 'cm') return mm / 10;
            return mm;
        }

        function setupColorPicker() {
            // HSV/Hex Helpers
            function hsvToHex(h, s, v) {
                s /= 100; v /= 100;
                let c = v * s, x = c * (1 - Math.abs(((h / 60) % 2) - 1)), m = v - c, r = 0, g = 0, b = 0;
                if (0 <= h && h < 60) { r = c; g = x; b = 0; }
                else if (60 <= h && h < 120) { r = x; g = c; b = 0; }
                else if (120 <= h && h < 180) { r = 0; g = c; b = x; }
                else if (180 <= h && h < 240) { r = 0; g = x; b = c; }
                else if (240 <= h && h < 300) { r = x; g = 0; b = c; }
                else if (300 <= h && h < 360) { r = c; g = 0; b = x; }
                return "#" + [r, g, b].map(x => Math.round((x + m) * 255).toString(16).padStart(2, "0")).join("");
            }

            function hexToHsv(hex) {
                let r = parseInt(hex.substring(1, 3), 16) / 255;
                let g = parseInt(hex.substring(3, 5), 16) / 255;
                let b = parseInt(hex.substring(5, 7), 16) / 255;
                let max = Math.max(r, g, b), min = Math.min(r, g, b);
                let h, s, v = max;
                let d = max - min;
                s = max === 0 ? 0 : d / max;
                if (max === min) h = 0;
                else {
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h /= 6;
                }
                return { h: h * 360, s: s * 100, v: v * 100 };
            }

            function updateColorUI() {
                const hex = hsvToHex(state.color.h, state.color.s, state.color.v);
                state.hex = hex;
                DOM.colorPreview.style.backgroundColor = hex;
                DOM.hexInput.value = hex.substring(1).toUpperCase();
                DOM.cpSat.style.backgroundColor = `hsl(${state.color.h}, 100%, 50%)`;
                DOM.cpHueThumb.style.left = `${(state.color.h / 360) * 100}%`;
                DOM.cpSatThumb.style.left = `${state.color.s}%`;
                DOM.cpSatThumb.style.top = `${100 - state.color.v}%`;
            }

            let dragSat = false;
            function setSat(e) {
                const rect = DOM.cpSat.getBoundingClientRect();
                let x = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
                let y = Math.max(0, Math.min(1, (e.clientY - rect.top) / rect.height));
                state.color.s = x * 100;
                state.color.v = 100 - (y * 100);
                updateColorUI();
            }

            DOM.cpSat.addEventListener('mousedown', e => { dragSat = true; setSat(e); });
            window.addEventListener('mousemove', e => { if (dragSat) setSat(e); });
            window.addEventListener('mouseup', () => dragSat = false);

            let dragHue = false;
            function setHue(e) {
                const rect = DOM.cpHue.getBoundingClientRect();
                let x = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
                state.color.h = x * 360;
                updateColorUI();
            }

            DOM.cpHue.addEventListener('mousedown', e => { dragHue = true; setHue(e); });
            window.addEventListener('mousemove', e => { if (dragHue) setHue(e); });
            window.addEventListener('mouseup', () => dragHue = false);

            DOM.hexInput.addEventListener('change', () => {
                let val = DOM.hexInput.value;
                if(!val.startsWith('#')) val = '#' + val;
                if(/^#[0-9A-F]{6}$/i.test(val)) {
                    state.color = hexToHsv(val);
                    updateColorUI();
                }
            });

            window.setColorFromHex = function(hex) {
                if (!hex || !/^#[0-9A-F]{6}$/i.test(hex)) return;
                state.color = hexToHsv(hex);
                updateColorUI();
            };

            DOM.addToPaletteBtn.addEventListener('click', () => {
                if (!state.palette.includes(state.hex)) {
                    state.palette.push(state.hex);
                    renderPalette();
                }
            });
            
            DOM.clearPaletteBtn.addEventListener('click', () => {
                state.palette = [];
                renderPalette();
            });

            updateColorUI();
        }

        function renderPalette() {
            DOM.paletteContainer.innerHTML = '';
            state.palette.forEach(color => {
                const div = document.createElement('div');
                div.className = 'w-6 h-6 rounded cursor-pointer border border-slate-200 shadow-sm hover:scale-110 transition-transform';
                div.style.backgroundColor = color;
                div.onclick = () => {
                    state.hex = color;
                    DOM.colorPreview.style.backgroundColor = color;
                    DOM.hexInput.value = color.substring(1);
                };
                DOM.paletteContainer.appendChild(div);
            });
        }

        init();

    </script>
</body>
</html>


